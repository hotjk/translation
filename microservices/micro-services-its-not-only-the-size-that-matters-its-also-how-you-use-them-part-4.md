Microservices: It’s not (only) the size that matters, it’s (also) how you use them – part 4

[第一部分](https://github.com/hotjk/translation/blob/master/microservices/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-1.md)
[第二部分](https://github.com/hotjk/translation/blob/master/microservices/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-2.md)
[第三部分](https://github.com/hotjk/translation/blob/master/microservices/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-3.md)
[第四部分](https://github.com/hotjk/translation/blob/master/microservices/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-4.md)
[第五部分](https://github.com/hotjk/translation/blob/master/microservices/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-5.md)

本文翻译自 Jeppe Cramon 在 [tigerteam.dk](https://www.tigerteam.dk) 的博客文章，原文地址：

> https://www.tigerteam.dk/2014/microservices-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-4/

第三部分我们谈到，为了确保我们的服务能高度自治，我们需要避免服务间的（同步）双向通信，而应该使用单向通信。

更高级别的自治同时也意味着更少的耦合，耦合越少，服务和数据的版本问题也就越少。
我们还提高了服务的稳定性 -- 其他服务执行时发生的错误不会直接影响我们的服务。

但是，怎样才能完成工作，如果我们只使用单向通信，我们的服务怎么返回数据呢？
直接的回答是你不能，但是拥有良好定义的服务边界，你的服务就不需要直接调用其它服务来获取数据，大多数情况是这样。

## 服务边界

什么是服务边界？这个词基本上表示一个服务负责的业务数据和业务功能。在 [SOA: synchronous communication, data ownership and coupling](http://www.tigerteam.dk/2014/soa-synchronous-communication-data-ownership-and-coupling/) 一文中对服务原则，比如边界和自治有更详细的介绍。
边界确定了那些是服务的内部，那些是服务的外部，在本文第二部分我们使用了聚合模式分析了那些数据属于 Legal Entity Service 的内部。
在 Legal Entity Service 的例子中，我们意识到 LegalEntity 和 Address 的关系是从属关系，因为 LegalEntity 和它相关的 Address 是同时创建、修改和删除的。把两个服务合并成一个服务，Legal Entity Service 做到了自治，进而避免了调用服务时出现错误时，要对其他操作数据服务的调用做编排的复杂场景。

Legal Entity 耦合的问题可以被轻松解决，但是如果数据和数据见的关系更复杂怎么办？仅仅把这些数据堆到一个服务里避免跨处理边界的数据变更问题（比如不同的服务部署在不同的操作系统进程或者不同的物理服务器上），这样做的话很快我们就会被拉回 Monolith 的方式。Monolith 本身没什么错，也可以使用许多相似的设计原则来构建 Monolith 应用，比如可以用模块来代替微服务，模块也可以一起打包后一起部署，就像微服务经常被独立部署一样（独立部署常常被认为是微服务带来的优点）。

## 模糊的边界 -- Monolith 滑坡

Monolith 的一个问题是模糊边界的风险。因为模块是紧密绑定在一起的，常常在同一个代码库内，这样会造成一种缓慢恶化的倾向，导致了模块间越来越多的耦合，因为实在是太容易调用其它函数、组件或者 Join 其他表。

Monolith 感觉好极了，特别是在项目初期，问题很少，复杂度也不高，Monolith 还有一种趋势，会导致其以数据和功能逻辑的形式承担过多的职责。

开发 Monolith 应用时，你可以：

- 本地优势。比如执行内存调用避免分布式事务，Join 处于同一个 DB 下的其他 SQL 表格
- 利用开发工具的重构、代码自动补全、代码查询等能力

硬币的另一面是高耦合和低内聚的风险，Monolith 很容易慢慢的变大，因为他承担了太多的职责，因为太容易使用已有的功能和数据。

![Monolith 数据模型慢慢变大最终因为缺乏内聚而变得混乱](https://github.com/hotjk/translation/blob/master/microservices/Image/model-growth.png?raw=true)

这就是 Monolith 走下坡路：

![Monolith 随着复杂度下滑](https://github.com/hotjk/translation/blob/master/microservices/Image/monolith-slippery-slope.png?raw=true)

Monolith 还有几个劣势：

- 很难适应新技术 -- 要使用新的框架/语言/技术常常需要重写整个 Monolith 应用
- 可重用性差 -- 功能部分不能单独重用
- 交付缓慢 -- 新功能引入需要协调其他功能一起发布
- 应用的大小和职责越来越大
- 越来越高的耦合
- 启动要用很长时间
- 测试要用很长时间
- Monolith 要求你的大脑要同时容纳大量的业务概念，而人对复杂度的掌控是有限的
- 可靠性 -- 一个业务出了问题（比如内存溢出）会导致整个 Monolith 系统宕机

你可以在设计 Monolith 时定义内部的服务和组件并且定义好边界使他们保持松散的耦合，但是从我 20 多年的经验来看，使用这种模式的应用基本都是大泥球。

## 集成成堆的 Web Service

我看到的许多机构实施 SOA 的方案都是在已存在的 Monolith 系统上加上 Web Service，这种方式有其意义，可以使老的 Monolith 系统被复用。

问题是大多数 Monolith 系统已经发展到了包含许多不同类型的业务。这意味着公司最终不得不有多个主系统，这些系统拥有很多相似的业务数据，每种业务都没有真正的单一源头。

![Monolith 集成成堆的 Web Service](https://github.com/hotjk/translation/blob/master/microservices/Image/integration-by-a-bunch-of-webservices.png?raw=true)

如果我们刚接手一个 Monolith 系统，想要拆分成小一点的服务，我们还需要处理 Monolith 系统的内部耦合，典型的内部耦合包括集成、直接的方法调用、SQL Join 等等。如果我们只是简单的创建服务只会让事情更糟。

![Monolith 分拆成服务](https://github.com/hotjk/translation/blob/master/microservices/Image/monolith-sliced-up-into-microservices.png?raw=true)

所有这些都导致了服务边界模糊，一些服务会很单薄并且会过度的依赖其他服务的数据和功能。在我看来，这不是松耦合，也许恰恰相反。

## 定义服务边界

当创建新服务或者从现有的 Monolith 分拆服务时，我们需要花时间定义服务的边界，所以我们可以避免使用服务间双向通信。
注意：高度自治并不是所有情况都需要的，可能有些场景使用双向通信时从开发角度看性价比更高，有些场景下缺乏自治是可以容忍的（比如跨越多个服务的读取）。

在旧有的 Monolith 系统，我们可能已经收集了关于零售领域的所有的功能和数据，可能包含的功能区有，商品目录、销售、库存、配送、结账，每一个功能区可以被叫做子域或者业务功能：

![零售领域的功能区](https://github.com/hotjk/translation/blob/master/microservices/Image/functional-areas.png?raw=true)

零售业务就是销售商品，所以每个功能区或者说子域都会以一些方式牵扯到商品（Product）这个领域概念：

- 商品目录子域里面的商品（Product）包含名称、描述、图片等等。
- 销售子域会创建商品订单。
- 库存子域关心商品的库存数量（QOH），还有商品所在位置等，这里我们用 Product 这个名字，也可以不用，根据库存相关的项目/商品的状态，有时候也可以叫 Stock Item 或者 Back Ordered Item 等等。
- 价格子域关心商品的定价策略，可以包含根据客户状态的折扣（客户状态可能在另一个 CRM 大系统或服务里维护）。
- 配送子域关心商品的尺寸、重量以及发送目的地等。

如你所想，所有子域都跟商品发生了关联，子域可以给商品使用 Product 这个名字也可以给商品使用其他的名字（其他的领域概念比如 Customer 的命名也类似）。关联在商品上不同的数据也很有意思，库存子域关心库存单元（SKU）、库存数量（QOH）、库存位置代码，对库存子域来说，商品名称、图片之类的可能不关心，即使有了，也只是给库存工人工作提供帮助，不会是处理库存业务必须的。
另一方面，配送子域不会关心库存数量（QOH）、库存位置代码等等，他们关心商品尺寸、重量，也许会关心商品名称，如果要打印配送收据的话。
配送领域的这种不同视角在领域驱动设计（DDD）里被称为不同的界限上下文（Bounded Context）。

在 Monolith 系统，很容易会创建一个 Product 表，包含许多的属性和关联，不同子域只是在他们认为合适的地方插入/更新或者关联数据，风险是 Product 领域模型会变大，造成该模型变化的业务会有很多（违反单一职责原则），导致耦合和一致性缺失。
因为其他业务依赖它，你不能修改 Product 表结构，从托管代码到服务和服务协议的提升只是移除了技术耦合，实际上服务仍然需要其他服务的数据和功能，这将我们服务的自治性降低到不可接受的级别。

### 定义服务边界

我们需要一种方法来设计服务边界，这样我们的服务就可以不需要为获取数据或者调用功能而使用双向通信方式来互相沟通。

我们可以围绕着功能区或者业务范围来开始服务构建，并用这个作为服务的边界，服务拥有自己的数据和功能。
别的服务不允许拥有这个服务的的数据。
数据只能有一个所有者，有了这个保证，我们相信我们的服务是他所有的业务数据的唯一事实来源。

这样做确保我们的服务只需要响应业务功能负责的修改，这就是服务的单一职责原则（SRP），你可以越多关于 SRP 的谈论[这篇](http://www.udidahan.com/2014/05/26/people-politics-and-the-single-responsibility-principle/)和[这篇](http://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)。

注意：下面的例子是构建更松散耦合服务之路的第一步，定义服务边界可不容易，后面的文章会继续深入讨论如何用比我们现在描述的基本方法更好的方式来定义一致服务边界。我想很多人会争论商品目录是不是一个最好的服务边界，但是既然很多企业都用了商品目录的概念，这里我们也就沿用这个概念。

让我们开始商品目录服务的设计，商品聚合包含很多属性，比如名称、ID（聚合需要唯一 ID）、图片、描述等等，商品目录服务会是商品聚合的唯一事实来源。在销售服务中我们关心用户通过网上商城等途径选择商品构建订单，在销售服务我们关心每个具体的订单行特定 ID 商品对应的数量，在销售服务构建订单对象时我们不需要商品的名称。（网上商城需要商品的名称，但是这个用例只是读商品名称，在构建销售服务的订单对象时我们关注的是写用例）

服务模型和边界看起来是这样（简化版）

![简化的服务数据模型](https://github.com/hotjk/translation/blob/master/microservices/Image/simple-service-data-models.png?raw=true)

上面的服务领域模型展示了两个高内聚、低耦合、简单清晰的数据模型。两者唯一的耦合是订单行通过商品 ID 引用了商品（记得本文第二部分说过聚合间通过彼此 ID 引用）。
网上商城（消费许多服务的客户端）负责显示销售的商品，客户购买商品的价格，当用户塞满购物筐，网上商城会发送包含用户想购买的商品的数量、价格、商品 ID 的命令消息给销售服务。后面我们会看到我们怎样使用复合式 UI 的优势来降低网上商城的耦合，现在我们只是假设网上商城这个客户端使用双向通信方式逐个调用服务。
只要提供了数量、单价、和商品 ID 给销售服务，它就能创建订单、添加订单行，而不需要联系商品目录服务。

但是销售服务想要获取客户的订单确认时怎们办？当用户通过电子邮件收到订单确认，客户不单要看到价格、单价和商品 ID，客户还需要知道购买的商品的名称，甚至图片，这样客户才能确认订单里是他希望购买的商品。

在准备订单确认邮件时，销售服务需要保留从商品目录服务获得的商品名称么？
让我们看一下销售服务可能的做法：

- 常规方法：销售服务使用双向通信方式针对订单里的每个订单行调用商品目录服务（可以逐个调用，也可把所有订单行对应的商品打包一次调用获得一个集合）
  - 这意味着销售服务现在跟商品目录服务有更强的接口协议耦合和时间耦合，销售服务需要知道商品目录服务提供的具体的操作和数据。
  - 这意味着任何商品目录服务不向后兼容的改动都会连带造成销售服务的修改（即使这些改动是销售服务不关心的），或者商品目录服务需要对接口协议版本化。
  - 问题可以一定程度的解决，如果商品目录服务提供消费者驱动的接口协议，针对特定的客户，比如销售服务，提供客户特定的接口协议。
  - 如果商品目录服务宕机，因为时间耦合，销售服务不能进行订单确认了，这也许不是个大问题，因为订单确认的时间并不是特别重要，况且订单确认也不直接与客户交互。
  - 如果销售服务也负责渲染网上商城包含商品的界面，那么销售服务和商品目录服务的时间耦合就很严重了，仅仅因为商品目录不可用（比如因为 ERP 系统故障）就导致销售服务不能创建和接受新订单了。
- 2015年2月28日补充：还有其他有别于自治服务的 SOA 方案，其中一个值得一提，在[这个方案](http://www.infoq.com/minibooks/composite-software-construction)中，服务不需要自治也不需要拥有业务数据，不需要暴露刻意的接口，只需要负责协调不同记录系统（SoR）之间的交互。商品分类服务和销售服务将被归入记录系统（SoR），并且仍然是自治的，一个新的负责 “发送订单确认邮件” 用例的协调服务被引入进来，这个服务将会调用商品目录 SoR 和销售 SoR 来获取订单信息和商品信息，并将信息组合起来完成订单确认。服务操作可以仍然使用事件触发。
- 商品目录服务拆解到订单确认过程
  - 这种耦合更轻量更精细，因为销售服务并不需要知道商品目录服务内部数据和协议（除了 UI -定义的一个非常小的共享渲染上下文）。
  - 业务混搭仍然涉及到服务之间的时间耦合。
  - 我将在后面的文章中再谈组合 UI 混搭和服务混搭。
- 最后的方案是销售服务包含商品目录数据的缓存或者复制，这可以工作，没有对商品目录服务的时间耦合，通过使用基于事件的数据复制。

### 通过事件进行数据复制

当从商品目录添加、修改或者删除商品时，我们注意到可以通过业务事件通知其他服务这一事实。
这种情况下，从业务角度来看商品分类服务非常简单，业务事件类似大家熟悉的增删改事件：ProductAdded、ProductUpdated
、ProductDeleted。
注意，事件以过去式来命名，事实上这很重要。

我们可以让销售服务通过消息通道（比如发布/订阅风格）监听这些事件，并允许销售服务建立其内部的商品对象，并将自己关心的数据放入新的商品对象：

![通过事件进行数据复制](https://github.com/hotjk/translation/blob/master/microservices/Image/data-duplication-over-events.png?raw=true)

对应的服务数据模型：

![包含时间和数据复制的服务模型](https://github.com/hotjk/translation/blob/master/microservices/Image/Data-duplication.png?raw=true)

使用数据复制方案获得以下优势：

- 数据所有权清晰，商品目录是数据的所有者，当数据变更时通知相关服务。
   - 这种形式的数据缓存技术比多数传统缓存机制更好。数据变更时立即可以获得事件通知，传统的缓存机制无法从数据所有者那里获得即时的通知和指示，这会导致自己保留了无效的数据。
- 协议耦合度低。你只会绑定到仅包含数据的事件协议，事件协议比既包含数据也包含功能的传统 WSDL 服务协议简单的多。经验表明，事件协议往往比包含功能的标准协议更稳定。不过设计时仍然必须考虑向前兼容，才可能在添加非强制字段时不导致现有的事件订阅者出问题。
- 商品目录服务和销售服务之间的耦合度非常低。
  - 销售服务只需要知道事件协议和消息通道地址。
  - 商品目录服务没有任何对销售服务的耦合，他不知道销售服务收到事件后会怎么处理，事实上商品目录都不知道什么服务收到了它发出的事件。
- 以牺牲强一致性保留最终一致性为代价解除了时间耦合和技术耦合。
  - Pat Hellands 的 [Life Beyond Distributed Transactions – An Apostate’s Opinion](http://www-db.cs.wisc.edu/cidr/cidr2007/papers/cidr07p15.pdf) 一文中有值得学习的地方。文中，他总结了你只需要在一个聚合实例内保持一致性（也就是在一个服务的一个事务内），聚合实例间只需要最终一致性，因为我们没有办法在聚合实例之间保持强一致性，除非我们打算付出分布式事务的高额代价。
  - 在这里，最终一致性意味着如果消息通道故障导致消息不能发送给销售服务，即使商品名称变更了，在订单确认时我们使用的还是原来的商品名称，一旦消息通道恢复可用，销售服务会收到商品目录服务发送来的消息，当使用缓存时，只能遵循最终一致性的标准，不管是否使用事件机制。
  - 通过把事件跟时间关联，我们可以减少最终一致性造成的问题。事件包含名称和数据，在数据中你可以通知接收者未来多长时间内数据中的值是有效且可以被缓存的（比如价格只会每天变化，商品名称很少变化，等等）。

怀疑论者可以觉得通过事件做数据复制比起使用现有的数据库技术来实现要多做很多事，这个观念倒也没什么错，通过事件进行数据复制也有它的复杂性，比如监控、通道配置、IO 成本，因为复制了数据，服务还需要更多的内存和存储空间。
通过事件进行数据复制是一种众所周知、技术中立的模式用于慢慢的拆分 Monolith 应用到自治服务，但是基于事件的集成方案不是最终解决方案。
当我们走的更远，就会有更多收获，这个收获就是，事件可以驱动业务处理。

### 使用跨服务业务事件驱动业务处理

如果我们把增删改事件提升为真实的业务事件，以反应聚合的状态变化，那么我们就可以用这些事件驱动业务操作，代替调度中心（编排）通过双向通信方式来协调业务处理。

让我们看看怎样使用事件来驱动订单处理流程。客户在网上商城按下接受按钮时，触发一个 AcceptOrder 命令消息发送（通常是异步）给销售服务。

![OrderAccepted 事件驱动订单处理流程](https://github.com/hotjk/translation/blob/master/microservices/Image/OrderAccepted1.png?raw=true)

AccpetOrder 命令导致订单状态改变，订单状态被转换为 Accepted 状态。
这种状态改变通过 OrderAccpeted 事件传达给所有对此感兴趣的服务，我们在描述一个订单已经被接受，这件事是不可撤销的（我们可以补偿，但是不能回滚这次改变）。
销售服务不知道谁对这个事件感兴趣，但是从公司业务层面，我们已经梳理了订单处理过程并决定了那些服务需要对 OrderAccepted 事件做出反馈。
这被称为响应式编程或者事件驱动架构（EDA），这跟传统的使用 “业务流程执行语言” 编排服务并指导服务做什么的方案很不一样。

EDA 服务自己决定当事件发生时要做什么，当我们需要协调多个服务的场合，比如确保客户已经付款并且订单里的所有商品都有货的时候才可以发货，我们将引入一个新的聚合来负责订单处理过程和能力。这个聚合是属于发货服务，还是一个独立的服务，现在还不重要，重要的是我们已经标识出一个明确可以分配职责的核心业务能力。

这样一个过程处理聚合可以实现为一个 Process Manager 或者 Saga（在 Rebus 和 NServiceBus 里这么叫），如果需要的话，Process Manager 可以选择指导其他服务具体做什么（也就是局部编排），但是通常通过单独使用事件就能解决。

在下面的例子中，订单处理服务发送 OrderReadyForShipping 事件之前等待两个事件：OrderAccepted 和 CustomerBilled，两个事件需要包含足够的信息，表达出他们是同一个订单处理过程，可以通过 OrderID，也可以通过其他形式的相关 ID，这种服务间使用事件的协作方式也被称作编排，可以被看成对更传统的编排的补充（真实的解决方案会联合使用两种编排方式）。

![编排的订单处理过程](https://github.com/hotjk/translation/blob/master/microservices/Image/orderfulfilment-process.png?raw=true)

事件驱动架构已经说的够多了，这篇已经太长了，服务边界定义放到下次吧。
